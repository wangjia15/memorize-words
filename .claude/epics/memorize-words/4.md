# Task 4: Authentication System

## Metadata
```yaml
epic: memorize-words
task_number: 4
title: Authentication System
status: pending
priority: high
effort_estimate: 10
parallel: false
dependencies: [3]
created: 2025-09-22T01:13:25Z
updated: 2025-09-22T01:34:36Z
assignee: developer
tags: [authentication, spring-security, jwt, user-management]
```

## Summary
Implement a comprehensive authentication and authorization system using Spring Security 6.x with JWT tokens, user registration, login, password management, and role-based access control for the memorize-words application.

## Acceptance Criteria
- [ ] User registration with email verification
- [ ] Secure login with JWT token generation
- [ ] Password hashing using BCrypt
- [ ] JWT token validation and refresh mechanism
- [ ] Role-based access control (USER, ADMIN)
- [ ] Password reset functionality
- [ ] Account lockout after failed attempts
- [ ] Logout and token invalidation
- [ ] Session management
- [ ] Security headers and CORS configuration
- [ ] Rate limiting for authentication endpoints
- [ ] Comprehensive security tests

## Technical Requirements

### Spring Security Configuration
```java
@Configuration
@EnableWebSecurity
@EnableMethodSecurity(prePostEnabled = true)
public class SecurityConfig {

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .csrf(csrf -> csrf.disable())
            .sessionManagement(session ->
                session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
            .authorizeHttpRequests(authz -> authz
                .requestMatchers("/api/auth/**").permitAll()
                .requestMatchers("/api/public/**").permitAll()
                .requestMatchers(HttpMethod.GET, "/api/health").permitAll()
                .requestMatchers("/api/admin/**").hasRole("ADMIN")
                .anyRequest().authenticated())
            .addFilterBefore(jwtAuthenticationFilter(),
                UsernamePasswordAuthenticationFilter.class)
            .exceptionHandling(ex -> ex
                .authenticationEntryPoint(authenticationEntryPoint())
                .accessDeniedHandler(accessDeniedHandler()));

        return http.build();
    }
}
```

### JWT Implementation
```java
@Component
public class JwtTokenProvider {

    @Value("${app.jwt.secret}")
    private String jwtSecret;

    @Value("${app.jwt.expiration}")
    private int jwtExpirationInMs;

    @Value("${app.jwt.refresh-expiration}")
    private int refreshExpirationInMs;

    public String generateToken(Authentication authentication) {
        UserPrincipal userPrincipal = (UserPrincipal) authentication.getPrincipal();
        Date expiryDate = new Date(System.currentTimeMillis() + jwtExpirationInMs);

        return Jwts.builder()
                .setSubject(Long.toString(userPrincipal.getId()))
                .setIssuedAt(new Date())
                .setExpiration(expiryDate)
                .signWith(SignatureAlgorithm.HS512, jwtSecret)
                .compact();
    }

    public String generateRefreshToken(Authentication authentication) {
        UserPrincipal userPrincipal = (UserPrincipal) authentication.getPrincipal();
        Date expiryDate = new Date(System.currentTimeMillis() + refreshExpirationInMs);

        return Jwts.builder()
                .setSubject(Long.toString(userPrincipal.getId()))
                .setIssuedAt(new Date())
                .setExpiration(expiryDate)
                .signWith(SignatureAlgorithm.HS512, jwtSecret)
                .compact();
    }

    public boolean validateToken(String authToken) {
        try {
            Jwts.parser().setSigningKey(jwtSecret).parseClaimsJws(authToken);
            return true;
        } catch (JwtException | IllegalArgumentException e) {
            return false;
        }
    }

    public Long getUserIdFromToken(String token) {
        Claims claims = Jwts.parser()
                .setSigningKey(jwtSecret)
                .parseClaimsJws(token)
                .getBody();
        return Long.parseLong(claims.getSubject());
    }
}
```

### Authentication Controller
```java
@RestController
@RequestMapping("/api/auth")
@Validated
public class AuthController {

    @PostMapping("/register")
    public ResponseEntity<ApiResponse> registerUser(
            @Valid @RequestBody SignUpRequest signUpRequest) {
        // User registration logic
    }

    @PostMapping("/login")
    public ResponseEntity<JwtAuthenticationResponse> authenticateUser(
            @Valid @RequestBody LoginRequest loginRequest) {
        // Authentication logic
    }

    @PostMapping("/refresh")
    public ResponseEntity<JwtAuthenticationResponse> refreshToken(
            @Valid @RequestBody TokenRefreshRequest request) {
        // Token refresh logic
    }

    @PostMapping("/logout")
    @PreAuthorize("hasRole('USER')")
    public ResponseEntity<ApiResponse> logoutUser(
            HttpServletRequest request) {
        // Logout logic
    }

    @PostMapping("/forgot-password")
    public ResponseEntity<ApiResponse> forgotPassword(
            @Valid @RequestBody ForgotPasswordRequest request) {
        // Password reset initiation
    }

    @PostMapping("/reset-password")
    public ResponseEntity<ApiResponse> resetPassword(
            @Valid @RequestBody ResetPasswordRequest request) {
        // Password reset completion
    }
}
```

### DTOs and Requests
```java
@Data
public class SignUpRequest {
    @NotBlank
    @Size(min = 3, max = 15)
    private String username;

    @NotBlank
    @Size(max = 40)
    @Email
    private String email;

    @NotBlank
    @Size(min = 6, max = 20)
    private String password;

    private String firstName;
    private String lastName;
}

@Data
public class LoginRequest {
    @NotBlank
    private String usernameOrEmail;

    @NotBlank
    private String password;
}

@Data
public class JwtAuthenticationResponse {
    private String accessToken;
    private String refreshToken;
    private String tokenType = "Bearer";
    private Long expiresIn;
    private UserSummary user;
}
```

### User Service
```java
@Service
@Transactional
public class UserService {

    public User createUser(SignUpRequest signUpRequest) {
        // Check if username exists
        if (userRepository.existsByUsername(signUpRequest.getUsername())) {
            throw new BadRequestException("Username is already taken!");
        }

        // Check if email exists
        if (userRepository.existsByEmail(signUpRequest.getEmail())) {
            throw new BadRequestException("Email Address already in use!");
        }

        // Create user's account
        User user = new User();
        user.setUsername(signUpRequest.getUsername());
        user.setEmail(signUpRequest.getEmail());
        user.setFirstName(signUpRequest.getFirstName());
        user.setLastName(signUpRequest.getLastName());
        user.setPasswordHash(passwordEncoder.encode(signUpRequest.getPassword()));
        user.setRole(UserRole.USER);

        return userRepository.save(user);
    }

    public void initiatePasswordReset(String email) {
        User user = userRepository.findByEmail(email)
            .orElseThrow(() -> new ResourceNotFoundException("User", "email", email));

        String token = generatePasswordResetToken();
        user.setPasswordResetToken(token);
        user.setPasswordResetExpiry(LocalDateTime.now().plusHours(24));
        userRepository.save(user);

        emailService.sendPasswordResetEmail(user.getEmail(), token);
    }
}
```

### Security Features

#### Rate Limiting
```java
@Component
public class AuthenticationRateLimitFilter implements Filter {

    private final RateLimiter rateLimiter = RateLimiter.create(5.0); // 5 requests per second

    @Override
    public void doFilter(ServletRequest request, ServletResponse response,
                        FilterChain chain) throws IOException, ServletException {
        if (!rateLimiter.tryAcquire()) {
            HttpServletResponse httpResponse = (HttpServletResponse) response;
            httpResponse.setStatus(HttpStatus.TOO_MANY_REQUESTS.value());
            httpResponse.getWriter().write("Rate limit exceeded");
            return;
        }
        chain.doFilter(request, response);
    }
}
```

#### Account Lockout
```java
@Service
public class AccountLockoutService {

    private static final int MAX_ATTEMPTS = 5;
    private static final int LOCKOUT_DURATION_MINUTES = 30;

    public void recordFailedLoginAttempt(String username) {
        User user = userRepository.findByUsername(username).orElse(null);
        if (user != null) {
            user.setFailedLoginAttempts(user.getFailedLoginAttempts() + 1);
            if (user.getFailedLoginAttempts() >= MAX_ATTEMPTS) {
                user.setAccountLockedUntil(LocalDateTime.now().plusMinutes(LOCKOUT_DURATION_MINUTES));
            }
            userRepository.save(user);
        }
    }

    public void resetFailedLoginAttempts(String username) {
        User user = userRepository.findByUsername(username).orElse(null);
        if (user != null) {
            user.setFailedLoginAttempts(0);
            user.setAccountLockedUntil(null);
            userRepository.save(user);
        }
    }
}
```

## Implementation Details

### Key Components
1. **JWT Token Provider**: Token generation, validation, and parsing
2. **Authentication Filter**: JWT token validation on each request
3. **User Details Service**: Load user information for authentication
4. **Password Encoder**: BCrypt password hashing
5. **Authentication Entry Point**: Handle authentication failures
6. **Access Denied Handler**: Handle authorization failures

### Security Configuration
- CORS configuration for frontend integration
- Security headers (HSTS, XSS protection, etc.)
- Content Security Policy
- Rate limiting for authentication endpoints
- Session fixation protection

### Database Enhancements
```sql
-- Add authentication-related columns to users table
ALTER TABLE users ADD COLUMN failed_login_attempts INT DEFAULT 0;
ALTER TABLE users ADD COLUMN account_locked_until TIMESTAMP NULL;
ALTER TABLE users ADD COLUMN password_reset_token VARCHAR(255);
ALTER TABLE users ADD COLUMN password_reset_expiry TIMESTAMP NULL;
ALTER TABLE users ADD COLUMN email_verified BOOLEAN DEFAULT FALSE;
ALTER TABLE users ADD COLUMN email_verification_token VARCHAR(255);
```

## Testing Strategy
- Unit tests for JWT token operations
- Integration tests for authentication endpoints
- Security tests for unauthorized access
- Rate limiting tests
- Password reset flow tests
- Account lockout mechanism tests

## Definition of Done
- [ ] All authentication endpoints functional and tested
- [ ] JWT tokens properly generated and validated
- [ ] Password reset flow working end-to-end
- [ ] Account lockout prevents brute force attacks
- [ ] Rate limiting protects authentication endpoints
- [ ] Security headers properly configured
- [ ] All security tests pass
- [ ] Frontend integration working
- [ ] Documentation updated with authentication flow

## Notes
- Follow OWASP security best practices
- Implement proper error handling without information leakage
- Consider implementing 2FA in future iterations
- Ensure compliance with data protection regulations
- Monitor authentication attempts and failures
