# Task 002: Database Schema Design

## Metadata
```yaml
epic: memorize-words
task_number: 002
title: Database Schema Design
status: pending
priority: high
effort_estimate: 12
parallel: false
dependencies: [001]
created: 2025-09-22T01:13:25Z
updated: 2025-09-22T01:13:25Z
assignee: developer
tags: [database, jpa, mysql, schema, entities]
```

## Summary
Design and implement the complete database schema for the memorize-words application using JPA entities, including user management, word collections, learning progress tracking, and spaced repetition algorithm support.

## Acceptance Criteria
- [ ] Complete JPA entity model implemented
- [ ] MySQL database schema created and validated
- [ ] Database migrations/initialization scripts
- [ ] Repository interfaces with custom queries
- [ ] Entity relationships properly configured
- [ ] Database indexes optimized for performance
- [ ] Sample/seed data for development environment
- [ ] Integration tests for all repositories
- [ ] Database connection pooling configured
- [ ] Data validation annotations implemented

## Technical Requirements

### Core Entities

#### User Entity
```java
@Entity
@Table(name = "users")
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(unique = true, nullable = false)
    private String username;

    @Column(unique = true, nullable = false)
    private String email;

    @Column(nullable = false)
    private String passwordHash;

    private String firstName;
    private String lastName;
    private String preferredLanguage;

    @Enumerated(EnumType.STRING)
    private UserRole role;

    @CreationTimestamp
    private LocalDateTime createdAt;

    @UpdateTimestamp
    private LocalDateTime updatedAt;

    // Relationships
    @OneToMany(mappedBy = "user", cascade = CascadeType.ALL)
    private Set<WordCollection> collections;

    @OneToMany(mappedBy = "user", cascade = CascadeType.ALL)
    private Set<LearningProgress> learningProgress;
}
```

#### Word Entity
```java
@Entity
@Table(name = "words")
public class Word {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private String word;

    @Column(columnDefinition = "TEXT")
    private String definition;

    @Column(columnDefinition = "TEXT")
    private String pronunciation;

    @Enumerated(EnumType.STRING)
    private PartOfSpeech partOfSpeech;

    @Enumerated(EnumType.STRING)
    private DifficultyLevel difficulty;

    @Column(name = "source_language")
    private String sourceLanguage;

    @Column(name = "target_language")
    private String targetLanguage;

    @CreationTimestamp
    private LocalDateTime createdAt;

    // Relationships
    @OneToMany(mappedBy = "word", cascade = CascadeType.ALL)
    private Set<WordExample> examples;

    @OneToMany(mappedBy = "word", cascade = CascadeType.ALL)
    private Set<WordTranslation> translations;

    @ManyToMany(mappedBy = "words")
    private Set<WordCollection> collections;
}
```

#### WordCollection Entity
```java
@Entity
@Table(name = "word_collections")
public class WordCollection {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private String name;

    @Column(columnDefinition = "TEXT")
    private String description;

    @Enumerated(EnumType.STRING)
    private CollectionType type; // PERSONAL, SHARED, SYSTEM

    private boolean isPublic;

    @CreationTimestamp
    private LocalDateTime createdAt;

    @UpdateTimestamp
    private LocalDateTime updatedAt;

    // Relationships
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id")
    private User user;

    @ManyToMany
    @JoinTable(
        name = "collection_words",
        joinColumns = @JoinColumn(name = "collection_id"),
        inverseJoinColumns = @JoinColumn(name = "word_id")
    )
    private Set<Word> words;
}
```

#### LearningProgress Entity
```java
@Entity
@Table(name = "learning_progress")
public class LearningProgress {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id")
    private User user;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "word_id")
    private Word word;

    @Enumerated(EnumType.STRING)
    private MasteryLevel masteryLevel; // NEW, LEARNING, FAMILIAR, MASTERED

    private int correctAnswers;
    private int totalAttempts;
    private int consecutiveCorrect;

    @Column(name = "ease_factor")
    private double easeFactor; // For spaced repetition algorithm

    @Column(name = "interval_days")
    private int intervalDays;

    @Column(name = "next_review_date")
    private LocalDateTime nextReviewDate;

    @Column(name = "last_reviewed")
    private LocalDateTime lastReviewed;

    @CreationTimestamp
    private LocalDateTime createdAt;

    @UpdateTimestamp
    private LocalDateTime updatedAt;
}
```

#### StudySession Entity
```java
@Entity
@Table(name = "study_sessions")
public class StudySession {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id")
    private User user;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "collection_id")
    private WordCollection collection;

    @Enumerated(EnumType.STRING)
    private StudyMode studyMode; // FLASHCARDS, QUIZ, TYPING, LISTENING

    private LocalDateTime startedAt;
    private LocalDateTime completedAt;

    private int totalWords;
    private int correctAnswers;
    private int duration; // in seconds

    @OneToMany(mappedBy = "studySession", cascade = CascadeType.ALL)
    private Set<StudySessionResult> results;
}
```

### Database Configuration
- MySQL 8.0+ compatibility
- Connection pooling (HikariCP)
- JPA/Hibernate configuration
- Database migrations using Flyway
- Proper indexing strategy
- Foreign key constraints

### Performance Considerations
- Indexed columns: username, email, word, next_review_date
- Optimized queries for learning progress tracking
- Efficient collection-word mapping
- Pagination support for large datasets

## Implementation Details

### Repository Interfaces
```java
@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    Optional<User> findByUsername(String username);
    Optional<User> findByEmail(String email);
    boolean existsByUsername(String username);
    boolean existsByEmail(String email);
}

@Repository
public interface WordRepository extends JpaRepository<Word, Long> {
    List<Word> findBySourceLanguageAndTargetLanguage(String source, String target);
    Page<Word> findByWordContainingIgnoreCase(String word, Pageable pageable);
    List<Word> findByDifficulty(DifficultyLevel difficulty);
}

@Repository
public interface LearningProgressRepository extends JpaRepository<LearningProgress, Long> {
    List<LearningProgress> findByUserAndNextReviewDateBefore(User user, LocalDateTime date);
    Optional<LearningProgress> findByUserAndWord(User user, Word word);
    long countByUserAndMasteryLevel(User user, MasteryLevel level);

    @Query("SELECT lp FROM LearningProgress lp WHERE lp.user = :user " +
           "AND lp.nextReviewDate <= :reviewDate ORDER BY lp.nextReviewDate ASC")
    List<LearningProgress> findWordsForReview(@Param("user") User user,
                                            @Param("reviewDate") LocalDateTime reviewDate);
}
```

### Database Migration Scripts
- Flyway migration files for schema creation
- Seed data for development environment
- Index creation scripts
- Foreign key constraint definitions

## Testing Strategy
- Repository integration tests with @DataJpaTest
- Entity validation tests
- Database constraint tests
- Performance tests for complex queries
- Transaction boundary tests

## Definition of Done
- [ ] All entities properly mapped and tested
- [ ] Database schema created and validated
- [ ] Repository methods implemented and tested
- [ ] Sample data populated successfully
- [ ] Performance benchmarks meet requirements
- [ ] Database migrations run successfully
- [ ] Entity relationships work correctly
- [ ] All constraints properly enforced

## Notes
- Design supports future scalability
- Spaced repetition algorithm considerations included
- Flexible enough for different study modes
- Optimized for read-heavy workloads
- Consider partitioning strategies for large datasets