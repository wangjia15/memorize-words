# Task 007: Progress Tracking & Analytics

## Metadata
```yaml
epic: memorize-words
task_number: 007
title: Progress Tracking & Analytics
status: pending
priority: high
effort_estimate: 18
parallel: false
dependencies: [006]
created: 2025-09-22T01:13:25Z
updated: 2025-09-23T09:02:23Z
assignee: developer
tags: [analytics, statistics, progress-tracking, charts, dashboard, data-visualization, learning-insights]
```

## Summary
Implement comprehensive progress tracking and analytics system with interactive data visualizations using Chart.js. The system will provide detailed learning insights, performance metrics, progress trends, and predictive analytics to help users understand their learning journey and optimize their study habits.

## Acceptance Criteria
- [ ] Learning progress statistics calculation and tracking
- [ ] Interactive charts and graphs using Chart.js for data visualization
- [ ] Daily, weekly, monthly, and yearly progress views
- [ ] Learning streak tracking and milestone achievements
- [ ] Performance analytics with accuracy trends and response time metrics
- [ ] Word difficulty analysis and learning curve visualization
- [ ] Review pattern analysis and optimal study time recommendations
- [ ] Comparative progress analysis (current vs previous periods)
- [ ] Learning velocity tracking and predictions
- [ ] Achievement system with badges and rewards
- [ ] Exportable progress reports and statistics
- [ ] Real-time dashboard updates with live metrics

## Technical Requirements

### Progress Statistics Service
```java
@Service
@Transactional(readOnly = true)
public class ProgressStatisticsService {

    private final SpacedRepetitionCardRepository cardRepository;
    private final ReviewHistoryRepository reviewHistoryRepository;
    private final UserStatisticsRepository userStatisticsRepository;
    private final CacheManager cacheManager;

    @Cacheable(value = "progress-stats", key = "#user.id + '_' + #from + '_' + #to")
    public ProgressStatistics calculateProgressStatistics(User user, LocalDate from, LocalDate to) {
        return ProgressStatistics.builder()
            .userId(user.getId())
            .periodStart(from)
            .periodEnd(to)
            .totalWordsAdded(calculateTotalWordsAdded(user, from, to))
            .totalReviews(calculateTotalReviews(user, from, to))
            .correctReviews(calculateCorrectReviews(user, from, to))
            .averageAccuracy(calculateAverageAccuracy(user, from, to))
            .totalStudyTime(calculateTotalStudyTime(user, from, to))
            .averageSessionLength(calculateAverageSessionLength(user, from, to))
            .streakDays(calculateStreakDays(user, to))
            .longestStreak(calculateLongestStreak(user))
            .wordsLearned(calculateWordsLearned(user, from, to))
            .wordsMastered(calculateWordsMastered(user, from, to))
            .learningVelocity(calculateLearningVelocity(user, from, to))
            .retentionRate(calculateRetentionRate(user, from, to))
            .difficultyDistribution(calculateDifficultyDistribution(user, from, to))
            .dailyMetrics(calculateDailyMetrics(user, from, to))
            .weeklyMetrics(calculateWeeklyMetrics(user, from, to))
            .monthlyMetrics(calculateMonthlyMetrics(user, from, to))
            .performanceTrends(calculatePerformanceTrends(user, from, to))
            .optimalStudyTimes(calculateOptimalStudyTimes(user))
            .achievements(calculateAchievements(user, from, to))
            .predictions(generateLearningPredictions(user))
            .build();
    }

    private int calculateTotalWordsAdded(User user, LocalDate from, LocalDate to) {
        return cardRepository.countByUserAndCreatedDateBetween(
            user, from.atStartOfDay(), to.atTime(23, 59, 59));
    }

    private int calculateTotalReviews(User user, LocalDate from, LocalDate to) {
        return reviewHistoryRepository.countByUserAndReviewDateBetween(
            user, from.atStartOfDay(), to.atTime(23, 59, 59));
    }

    private double calculateAverageAccuracy(User user, LocalDate from, LocalDate to) {
        List<ReviewHistory> reviews = reviewHistoryRepository.findByUserAndReviewDateBetween(
            user, from.atStartOfDay(), to.atTime(23, 59, 59));

        if (reviews.isEmpty()) return 0.0;

        long correctReviews = reviews.stream()
            .filter(review -> review.getOutcome() == ReviewOutcome.GOOD ||
                            review.getOutcome() == ReviewOutcome.EASY)
            .count();

        return (double) correctReviews / reviews.size() * 100;
    }

    private Duration calculateTotalStudyTime(User user, LocalDate from, LocalDate to) {
        List<ReviewSession> sessions = reviewHistoryRepository.findSessionsByUserAndDateBetween(
            user, from.atStartOfDay(), to.atTime(23, 59, 59));

        return sessions.stream()
            .map(session -> Duration.between(session.getStartTime(), session.getEndTime()))
            .reduce(Duration.ZERO, Duration::plus);
    }

    private int calculateStreakDays(User user, LocalDate endDate) {
        LocalDate currentDate = endDate;
        int streak = 0;

        while (hasReviewActivity(user, currentDate)) {
            streak++;
            currentDate = currentDate.minusDays(1);
        }

        return streak;
    }

    private LearningVelocity calculateLearningVelocity(User user, LocalDate from, LocalDate to) {
        long totalDays = ChronoUnit.DAYS.between(from, to);
        if (totalDays == 0) return new LearningVelocity(0, 0, 0);

        int newWords = calculateTotalWordsAdded(user, from, to);
        int learnedWords = calculateWordsLearned(user, from, to);
        int masteredWords = calculateWordsMastered(user, from, to);

        return LearningVelocity.builder()
            .newWordsPerDay((double) newWords / totalDays)
            .learnedWordsPerDay((double) learnedWords / totalDays)
            .masteredWordsPerDay((double) masteredWords / totalDays)
            .build();
    }

    private List<DailyMetric> calculateDailyMetrics(User user, LocalDate from, LocalDate to) {
        List<DailyMetric> metrics = new ArrayList<>();
        LocalDate current = from;

        while (!current.isAfter(to)) {
            LocalDate day = current;
            DailyMetric metric = DailyMetric.builder()
                .date(day)
                .wordsAdded(calculateTotalWordsAdded(user, day, day))
                .reviewsCompleted(calculateTotalReviews(user, day, day))
                .accuracy(calculateAverageAccuracy(user, day, day))
                .studyTime(calculateTotalStudyTime(user, day, day))
                .hasActivity(hasReviewActivity(user, day))
                .build();

            metrics.add(metric);
            current = current.plusDays(1);
        }

        return metrics;
    }

    private PerformanceTrend calculatePerformanceTrends(User user, LocalDate from, LocalDate to) {
        List<DailyMetric> dailyMetrics = calculateDailyMetrics(user, from, to);

        // Calculate trends using linear regression
        double accuracyTrend = calculateTrend(dailyMetrics, DailyMetric::getAccuracy);
        double velocityTrend = calculateTrend(dailyMetrics,
            metric -> (double) metric.getWordsAdded());
        double studyTimeTrend = calculateTrend(dailyMetrics,
            metric -> metric.getStudyTime().toMinutes());

        return PerformanceTrend.builder()
            .accuracyTrend(accuracyTrend)
            .velocityTrend(velocityTrend)
            .studyTimeTrend(studyTimeTrend)
            .trendDirection(determineTrendDirection(accuracyTrend))
            .build();
    }

    private List<Achievement> calculateAchievements(User user, LocalDate from, LocalDate to) {
        List<Achievement> achievements = new ArrayList<>();
        ProgressStatistics stats = calculateProgressStatistics(user, from, to);

        // Streak achievements
        if (stats.getStreakDays() >= 7) {
            achievements.add(createAchievement("WEEK_STREAK", "7-Day Streak",
                "Studied for 7 consecutive days"));
        }
        if (stats.getStreakDays() >= 30) {
            achievements.add(createAchievement("MONTH_STREAK", "30-Day Streak",
                "Studied for 30 consecutive days"));
        }

        // Accuracy achievements
        if (stats.getAverageAccuracy() >= 90) {
            achievements.add(createAchievement("ACCURACY_MASTER", "Accuracy Master",
                "Achieved 90% accuracy"));
        }

        // Volume achievements
        if (stats.getTotalReviews() >= 100) {
            achievements.add(createAchievement("REVIEW_CHAMPION", "Review Champion",
                "Completed 100 reviews"));
        }

        return achievements;
    }

    private LearningPrediction generateLearningPredictions(User user) {
        // Analyze historical data to predict future performance
        LocalDate sixMonthsAgo = LocalDate.now().minusMonths(6);
        ProgressStatistics historicalStats = calculateProgressStatistics(user, sixMonthsAgo, LocalDate.now());

        return LearningPrediction.builder()
            .predictedWordsInMonth(predictWordsInTimeframe(user, 30))
            .predictedAccuracy(predictAccuracyTrend(user))
            .estimatedMasteryTime(estimateMasteryTimeRemaining(user))
            .recommendedDailyGoal(calculateRecommendedDailyGoal(user))
            .build();
    }
}
```

### Analytics Data Models
```java
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ProgressStatistics {
    private Long userId;
    private LocalDate periodStart;
    private LocalDate periodEnd;
    private int totalWordsAdded;
    private int totalReviews;
    private int correctReviews;
    private double averageAccuracy;
    private Duration totalStudyTime;
    private Duration averageSessionLength;
    private int streakDays;
    private int longestStreak;
    private int wordsLearned;
    private int wordsMastered;
    private LearningVelocity learningVelocity;
    private double retentionRate;
    private DifficultyDistribution difficultyDistribution;
    private List<DailyMetric> dailyMetrics;
    private List<WeeklyMetric> weeklyMetrics;
    private List<MonthlyMetric> monthlyMetrics;
    private PerformanceTrend performanceTrends;
    private List<LocalTime> optimalStudyTimes;
    private List<Achievement> achievements;
    private LearningPrediction predictions;
}

@Data
@Builder
public class DailyMetric {
    private LocalDate date;
    private int wordsAdded;
    private int reviewsCompleted;
    private double accuracy;
    private Duration studyTime;
    private boolean hasActivity;
    private int streakDay;
}

@Data
@Builder
public class WeeklyMetric {
    private LocalDate weekStart;
    private LocalDate weekEnd;
    private int totalWords;
    private int totalReviews;
    private double averageAccuracy;
    private Duration totalStudyTime;
    private int activeDays;
}

@Data
@Builder
public class PerformanceTrend {
    private double accuracyTrend;
    private double velocityTrend;
    private double studyTimeTrend;
    private TrendDirection trendDirection;
    private double confidenceScore;
}

@Data
@Builder
public class LearningPrediction {
    private int predictedWordsInMonth;
    private double predictedAccuracy;
    private Duration estimatedMasteryTime;
    private int recommendedDailyGoal;
    private double confidenceLevel;
}
```

### Chart.js Integration Components
```typescript
import {
  Chart as ChartJS,
  CategoryScale,
  LinearScale,
  PointElement,
  LineElement,
  BarElement,
  Title,
  Tooltip,
  Legend,
  ArcElement,
  Filler
} from 'chart.js';
import { Line, Bar, Doughnut, Radar } from 'react-chartjs-2';

ChartJS.register(
  CategoryScale,
  LinearScale,
  PointElement,
  LineElement,
  BarElement,
  Title,
  Tooltip,
  Legend,
  ArcElement,
  Filler
);

export interface ProgressChartProps {
  data: ProgressStatistics;
  timeframe: 'daily' | 'weekly' | 'monthly';
  metric: 'accuracy' | 'reviews' | 'studyTime' | 'wordsAdded';
}

export const ProgressChart: React.FC<ProgressChartProps> = ({
  data,
  timeframe,
  metric
}) => {
  const chartData = useMemo(() => {
    const metrics = timeframe === 'daily' ? data.dailyMetrics :
                   timeframe === 'weekly' ? data.weeklyMetrics :
                   data.monthlyMetrics;

    const labels = metrics.map(m =>
      timeframe === 'daily' ? format(m.date, 'MMM dd') :
      timeframe === 'weekly' ? `Week of ${format(m.weekStart, 'MMM dd')}` :
      format(m.date, 'MMM yyyy')
    );

    const values = metrics.map(m => {
      switch (metric) {
        case 'accuracy': return m.accuracy;
        case 'reviews': return m.reviewsCompleted || m.totalReviews;
        case 'studyTime': return (m.studyTime || m.totalStudyTime).toMinutes();
        case 'wordsAdded': return m.wordsAdded || m.totalWords;
        default: return 0;
      }
    });

    return {
      labels,
      datasets: [{
        label: getMetricLabel(metric),
        data: values,
        borderColor: getMetricColor(metric),
        backgroundColor: `${getMetricColor(metric)}20`,
        fill: true,
        tension: 0.4,
        pointRadius: 4,
        pointHoverRadius: 6
      }]
    };
  }, [data, timeframe, metric]);

  const options = {
    responsive: true,
    maintainAspectRatio: false,
    plugins: {
      legend: {
        position: 'top' as const,
      },
      title: {
        display: true,
        text: `${getMetricLabel(metric)} Over Time (${timeframe})`
      },
      tooltip: {
        callbacks: {
          label: (context: any) => {
            const value = context.parsed.y;
            const unit = getMetricUnit(metric);
            return `${getMetricLabel(metric)}: ${value}${unit}`;
          }
        }
      }
    },
    scales: {
      y: {
        beginAtZero: true,
        title: {
          display: true,
          text: getMetricLabel(metric)
        }
      }
    },
    interaction: {
      intersect: false,
      mode: 'index' as const
    }
  };

  return (
    <div className="h-96 w-full">
      <Line data={chartData} options={options} />
    </div>
  );
};

export const AccuracyTrendChart: React.FC<{ data: ProgressStatistics }> = ({ data }) => {
  const chartData = {
    labels: data.dailyMetrics.map(m => format(m.date, 'MMM dd')),
    datasets: [
      {
        label: 'Daily Accuracy',
        data: data.dailyMetrics.map(m => m.accuracy),
        borderColor: 'rgb(59, 130, 246)',
        backgroundColor: 'rgba(59, 130, 246, 0.1)',
        fill: true,
        tension: 0.4
      },
      {
        label: 'Trend Line',
        data: calculateTrendLine(data.dailyMetrics.map(m => m.accuracy)),
        borderColor: 'rgb(239, 68, 68)',
        borderDash: [5, 5],
        fill: false,
        pointRadius: 0
      }
    ]
  };

  return (
    <Card>
      <CardHeader>
        <CardTitle>Accuracy Trend Analysis</CardTitle>
      </CardHeader>
      <CardContent>
        <div className="h-80">
          <Line data={chartData} options={{
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              tooltip: {
                callbacks: {
                  label: (context) => `${context.dataset.label}: ${context.parsed.y.toFixed(1)}%`
                }
              }
            }
          }} />
        </div>
      </CardContent>
    </Card>
  );
};

export const StudyPatternHeatmap: React.FC<{ data: ProgressStatistics }> = ({ data }) => {
  const heatmapData = useMemo(() => {
    // Create 7x24 grid for days of week vs hours
    const grid = Array(7).fill(null).map(() => Array(24).fill(0));

    // Populate with study session data
    data.dailyMetrics.forEach(metric => {
      if (metric.hasActivity) {
        const dayOfWeek = metric.date.getDay();
        // For each hour of activity (simplified - would need actual session times)
        for (let hour = 9; hour < 22; hour++) {
          grid[dayOfWeek][hour] += Math.random() * metric.studyTime.toMinutes() / 60;
        }
      }
    });

    return grid;
  }, [data]);

  return (
    <Card>
      <CardHeader>
        <CardTitle>Study Pattern Heatmap</CardTitle>
        <p className="text-sm text-muted-foreground">
          Your study activity by day of week and time of day
        </p>
      </CardHeader>
      <CardContent>
        <div className="grid grid-cols-24 gap-1 text-xs">
          {/* Hour labels */}
          <div className="col-span-24 grid grid-cols-24 gap-1 mb-2">
            {Array.from({length: 24}, (_, i) => (
              <div key={i} className="text-center text-xs text-muted-foreground">
                {i}
              </div>
            ))}
          </div>

          {/* Heatmap grid */}
          {['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'].map((day, dayIndex) => (
            <React.Fragment key={day}>
              <div className="text-xs text-muted-foreground py-1 pr-2">{day}</div>
              {heatmapData[dayIndex].map((intensity, hourIndex) => (
                <div
                  key={`${dayIndex}-${hourIndex}`}
                  className={`aspect-square rounded-sm ${getHeatmapColor(intensity)}`}
                  title={`${day} ${hourIndex}:00 - ${intensity.toFixed(1)} minutes`}
                />
              ))}
            </React.Fragment>
          ))}
        </div>
      </CardContent>
    </Card>
  );
};

export const LearningVelocityChart: React.FC<{ data: ProgressStatistics }> = ({ data }) => {
  const chartData = {
    labels: ['New Words', 'Words Learned', 'Words Mastered'],
    datasets: [{
      label: 'Per Day',
      data: [
        data.learningVelocity.newWordsPerDay,
        data.learningVelocity.learnedWordsPerDay,
        data.learningVelocity.masteredWordsPerDay
      ],
      backgroundColor: [
        'rgba(59, 130, 246, 0.8)',
        'rgba(16, 185, 129, 0.8)',
        'rgba(245, 158, 11, 0.8)'
      ],
      borderColor: [
        'rgb(59, 130, 246)',
        'rgb(16, 185, 129)',
        'rgb(245, 158, 11)'
      ],
      borderWidth: 2
    }]
  };

  return (
    <Card>
      <CardHeader>
        <CardTitle>Learning Velocity</CardTitle>
        <p className="text-sm text-muted-foreground">
          Your daily learning rate across different stages
        </p>
      </CardHeader>
      <CardContent>
        <div className="h-64">
          <Bar data={chartData} options={{
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: {
                display: false
              }
            },
            scales: {
              y: {
                beginAtZero: true,
                title: {
                  display: true,
                  text: 'Words per Day'
                }
              }
            }
          }} />
        </div>
      </CardContent>
    </Card>
  );
};

export const ProgressDashboard: React.FC = () => {
  const [timeframe, setTimeframe] = useState<'daily' | 'weekly' | 'monthly'>('daily');
  const [selectedMetric, setSelectedMetric] = useState<'accuracy' | 'reviews' | 'studyTime' | 'wordsAdded'>('accuracy');
  const [progressData, setProgressData] = useState<ProgressStatistics | null>(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    loadProgressData();
  }, [timeframe]);

  const loadProgressData = async () => {
    setLoading(true);
    try {
      const endDate = new Date();
      const startDate = new Date();

      switch (timeframe) {
        case 'daily':
          startDate.setDate(endDate.getDate() - 30);
          break;
        case 'weekly':
          startDate.setDate(endDate.getDate() - 90);
          break;
        case 'monthly':
          startDate.setFullYear(endDate.getFullYear() - 1);
          break;
      }

      const response = await api.get('/api/progress/statistics', {
        params: {
          from: startDate.toISOString().split('T')[0],
          to: endDate.toISOString().split('T')[0]
        }
      });

      setProgressData(response.data.data);
    } catch (error) {
      console.error('Failed to load progress data:', error);
    } finally {
      setLoading(false);
    }
  };

  if (loading || !progressData) {
    return <div className="flex justify-center p-8"><Spinner /></div>;
  }

  return (
    <div className="container mx-auto py-8 space-y-8">
      <div className="flex justify-between items-center">
        <h1 className="text-3xl font-bold">Learning Analytics</h1>

        <div className="flex gap-4">
          <Select value={timeframe} onValueChange={setTimeframe}>
            <SelectTrigger className="w-32">
              <SelectValue />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="daily">Daily</SelectItem>
              <SelectItem value="weekly">Weekly</SelectItem>
              <SelectItem value="monthly">Monthly</SelectItem>
            </SelectContent>
          </Select>

          <Select value={selectedMetric} onValueChange={setSelectedMetric}>
            <SelectTrigger className="w-40">
              <SelectValue />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="accuracy">Accuracy</SelectItem>
              <SelectItem value="reviews">Reviews</SelectItem>
              <SelectItem value="studyTime">Study Time</SelectItem>
              <SelectItem value="wordsAdded">Words Added</SelectItem>
            </SelectContent>
          </Select>
        </div>
      </div>

      {/* Key Metrics Cards */}
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6">
        <StatCard
          title="Current Streak"
          value={progressData.streakDays}
          unit="days"
          trend={progressData.streakDays > 0 ? 'up' : 'neutral'}
          icon={Flame}
        />
        <StatCard
          title="Average Accuracy"
          value={progressData.averageAccuracy.toFixed(1)}
          unit="%"
          trend={progressData.performanceTrends.accuracyTrend > 0 ? 'up' : 'down'}
          icon={Target}
        />
        <StatCard
          title="Total Study Time"
          value={formatDuration(progressData.totalStudyTime)}
          trend="neutral"
          icon={Clock}
        />
        <StatCard
          title="Words Mastered"
          value={progressData.wordsMastered}
          trend="up"
          icon={BookOpen}
        />
      </div>

      {/* Main Progress Chart */}
      <Card>
        <CardHeader>
          <CardTitle>Progress Overview</CardTitle>
        </CardHeader>
        <CardContent>
          <ProgressChart
            data={progressData}
            timeframe={timeframe}
            metric={selectedMetric}
          />
        </CardContent>
      </Card>

      {/* Secondary Charts Grid */}
      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
        <AccuracyTrendChart data={progressData} />
        <LearningVelocityChart data={progressData} />
        <StudyPatternHeatmap data={progressData} />
        <AchievementsPanel achievements={progressData.achievements} />
      </div>

      {/* Predictions and Recommendations */}
      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
        <PredictionsCard predictions={progressData.predictions} />
        <RecommendationsCard
          stats={progressData}
          optimalTimes={progressData.optimalStudyTimes}
        />
      </div>
    </div>
  );
};
```

## Implementation Details

### Key Features
1. **Comprehensive Analytics**: Detailed statistics on learning progress, accuracy, and performance
2. **Interactive Visualizations**: Chart.js integration for dynamic, responsive charts
3. **Trend Analysis**: Statistical analysis of performance trends and predictions
4. **Achievement System**: Gamification with badges and milestone tracking
5. **Personalized Insights**: Tailored recommendations based on individual patterns
6. **Real-time Updates**: Live dashboard with automatic data refresh

### Performance Optimizations
- Redis caching for frequently accessed statistics
- Database query optimization with proper indexing
- Lazy loading of chart data and components
- Background processing for complex analytics calculations
- Efficient data aggregation strategies

### Chart Types and Metrics
- Line charts for progress trends and accuracy over time
- Bar charts for learning velocity and volume metrics
- Heatmaps for study pattern analysis
- Doughnut charts for difficulty distribution
- Radar charts for multi-dimensional performance analysis

## Testing Strategy
- Unit tests for statistics calculation algorithms
- Integration tests for analytics API endpoints
- Component tests for chart rendering and interactions
- Performance tests for large datasets
- A/B testing for chart design effectiveness

## Definition of Done
- [ ] Progress statistics service implemented and tested
- [ ] Chart.js integration working with all chart types
- [ ] Real-time dashboard functional and responsive
- [ ] Caching system operational for performance
- [ ] Achievement system working correctly
- [ ] Analytics API endpoints tested and documented
- [ ] All statistics calculations accurate and validated
- [ ] Chart interactions and tooltips working properly
- [ ] Mobile-responsive chart layouts implemented

## Notes
- Consider implementing data export functionality for detailed reports
- Plan for scalability with large amounts of historical data
- Implement proper error handling for chart rendering failures
- Consider adding custom chart themes to match application design