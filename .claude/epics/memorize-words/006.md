# Task 006: Review System

## Metadata
```yaml
epic: memorize-words
task_number: 006
title: Review System
status: completed
priority: high
effort_estimate: 16
parallel: true
dependencies: [005]
created: 2025-09-22T01:13:25Z
updated: 2025-09-23T05:47:30Z
github: https://github.com/wangjia15/epic-memorize-words/issues/6
assignee: developer
tags: [review-system, spaced-repetition, algorithm, memory-retention, learning-optimization]
```

## Summary
Implement a comprehensive review system with advanced spaced repetition algorithms, multiple review modes, and intelligent scheduling to optimize long-term memory retention. The system will track learning progress, adapt to individual performance patterns, and provide personalized review schedules for maximum learning efficiency.

## Acceptance Criteria
- [ ] Spaced repetition algorithm implementation (SM-2, Anki-style, or custom)
- [ ] Multiple review modes (due words, difficult words, random review)
- [ ] Intelligent scheduling based on performance and forgetting curve
- [ ] Review streak tracking and motivation features
- [ ] Performance analytics and learning insights
- [ ] Customizable review parameters (interval modifiers, ease factors)
- [ ] Review notification system and reminders
- [ ] Adaptive difficulty adjustment during reviews
- [ ] Review session resume functionality
- [ ] Export/import of review data and statistics
- [ ] Integration with learning progress tracking
- [ ] Review optimization suggestions based on performance

## Technical Requirements

### Spaced Repetition Algorithm
```java
@Entity
@Table(name = "spaced_repetition_cards")
@Data
@EqualsAndHashCode(callSuper = true)
public class SpacedRepetitionCard extends BaseEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", nullable = false)
    private User user;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "word_id", nullable = false)
    private Word word;

    @Column(name = "ease_factor", precision = 4, scale = 2)
    private BigDecimal easeFactor = new BigDecimal("2.50");

    @Column(name = "interval_days")
    private Integer interval = 1;

    @Column(name = "repetition_count")
    private Integer repetitionCount = 0;

    @Column(name = "due_date")
    private LocalDateTime dueDate;

    @Column(name = "last_reviewed")
    private LocalDateTime lastReviewed;

    @Enumerated(EnumType.STRING)
    @Column(name = "card_state")
    private CardState state = CardState.NEW;

    @Column(name = "total_reviews")
    private Integer totalReviews = 0;

    @Column(name = "correct_reviews")
    private Integer correctReviews = 0;

    @Column(name = "average_response_time")
    private Integer averageResponseTime = 0;

    @Column(name = "difficulty_rating", precision = 3, scale = 2)
    private BigDecimal difficultyRating = BigDecimal.ZERO;

    @Column(name = "stability", precision = 4, scale = 2)
    private BigDecimal stability = new BigDecimal("1.00");

    @Column(name = "retrievability", precision = 4, scale = 2)
    private BigDecimal retrievability = new BigDecimal("1.00");

    @ElementCollection
    @Enumerated(EnumType.STRING)
    private List<ReviewOutcome> reviewHistory = new ArrayList<>();
}

public enum CardState {
    NEW,        // Never reviewed
    LEARNING,   // In initial learning phase
    REVIEW,     // In spaced repetition review
    RELEARNING, // Failed and back to learning
    SUSPENDED,  // Temporarily suspended
    BURIED      // Hidden until unburied
}

public enum ReviewOutcome {
    AGAIN(1),      // Complete blackout, incorrect response
    HARD(2),       // Incorrect response recalled with serious difficulty
    GOOD(3),       // Correct response with some difficulty
    EASY(4);       // Correct response with perfect recall

    private final int value;
}
```

### Spaced Repetition Service
```java
@Service
@Transactional
public class SpacedRepetitionService {

    private final SpacedRepetitionCardRepository cardRepository;
    private final ReviewHistoryRepository reviewHistoryRepository;
    private final UserPreferencesService preferencesService;

    // SM-2 Algorithm Implementation
    public SpacedRepetitionCard updateCard(SpacedRepetitionCard card, ReviewOutcome outcome, int responseTime) {
        card.setLastReviewed(LocalDateTime.now());
        card.setTotalReviews(card.getTotalReviews() + 1);
        card.getReviewHistory().add(outcome);

        // Update average response time
        updateAverageResponseTime(card, responseTime);

        switch (outcome) {
            case AGAIN:
                handleFailedReview(card);
                break;
            case HARD:
                handleHardReview(card);
                break;
            case GOOD:
                handleGoodReview(card);
                break;
            case EASY:
                handleEasyReview(card);
                break;
        }

        // Update stability and retrievability (FSRS algorithm elements)
        updateMemoryModel(card, outcome);

        // Calculate next due date
        calculateNextDueDate(card);

        return cardRepository.save(card);
    }

    private void handleFailedReview(SpacedRepetitionCard card) {
        card.setRepetitionCount(0);
        card.setInterval(1);
        card.setState(CardState.RELEARNING);

        // Reduce ease factor
        BigDecimal easeFactor = card.getEaseFactor().subtract(new BigDecimal("0.20"));
        card.setEaseFactor(easeFactor.max(new BigDecimal("1.30")));
    }

    private void handleHardReview(SpacedRepetitionCard card) {
        card.setRepetitionCount(card.getRepetitionCount() + 1);
        card.setCorrectReviews(card.getCorrectReviews() + 1);

        if (card.getState() == CardState.LEARNING || card.getState() == CardState.RELEARNING) {
            // Still in learning phase
            card.setInterval(Math.max(1, card.getInterval()));
        } else {
            // In review phase - reduce interval
            card.setInterval((int) (card.getInterval() * 1.2));
        }

        // Slightly reduce ease factor
        BigDecimal easeFactor = card.getEaseFactor().subtract(new BigDecimal("0.15"));
        card.setEaseFactor(easeFactor.max(new BigDecimal("1.30")));
    }

    private void handleGoodReview(SpacedRepetitionCard card) {
        card.setRepetitionCount(card.getRepetitionCount() + 1);
        card.setCorrectReviews(card.getCorrectReviews() + 1);

        if (card.getRepetitionCount() == 1) {
            card.setInterval(1);
        } else if (card.getRepetitionCount() == 2) {
            card.setInterval(6);
        } else {
            // SM-2 formula: I(n) = I(n-1) * EF
            card.setInterval((int) (card.getInterval() * card.getEaseFactor().doubleValue()));
        }

        if (card.getState() == CardState.LEARNING || card.getState() == CardState.RELEARNING) {
            if (card.getRepetitionCount() >= 2) {
                card.setState(CardState.REVIEW);
            }
        }
    }

    private void handleEasyReview(SpacedRepetitionCard card) {
        card.setRepetitionCount(card.getRepetitionCount() + 1);
        card.setCorrectReviews(card.getCorrectReviews() + 1);

        if (card.getRepetitionCount() == 1) {
            card.setInterval(4);
        } else {
            // Increase interval more aggressively for easy cards
            int newInterval = (int) (card.getInterval() * card.getEaseFactor().doubleValue() * 1.3);
            card.setInterval(newInterval);
        }

        // Increase ease factor for easy reviews
        BigDecimal easeFactor = card.getEaseFactor().add(new BigDecimal("0.15"));
        card.setEaseFactor(easeFactor.min(new BigDecimal("2.50")));

        card.setState(CardState.REVIEW);
    }

    private void updateMemoryModel(SpacedRepetitionCard card, ReviewOutcome outcome) {
        // Implement FSRS (Free Spaced Repetition Scheduler) memory model
        BigDecimal currentStability = card.getStability();
        BigDecimal currentRetrievability = card.getRetrievability();

        // Calculate new stability based on retrievability and outcome
        BigDecimal stabilityGain = calculateStabilityGain(currentRetrievability, outcome);
        BigDecimal newStability = currentStability.multiply(stabilityGain);

        card.setStability(newStability);

        // Update difficulty rating based on review history
        updateDifficultyRating(card);
    }

    private void calculateNextDueDate(SpacedRepetitionCard card) {
        UserPreferences prefs = preferencesService.getUserPreferences(card.getUser());

        LocalDateTime nextDue = card.getLastReviewed().plusDays(card.getInterval());

        // Apply user's timezone and preferences
        if (prefs.getPreferredReviewTime() != null) {
            nextDue = nextDue.with(prefs.getPreferredReviewTime());
        }

        // Add some randomization to prevent clustering
        int randomMinutes = ThreadLocalRandom.current().nextInt(-60, 61);
        nextDue = nextDue.plusMinutes(randomMinutes);

        card.setDueDate(nextDue);
    }

    @Transactional(readOnly = true)
    public List<SpacedRepetitionCard> getDueCards(User user, int limit) {
        LocalDateTime now = LocalDateTime.now();
        return cardRepository.findDueCardsForUser(user, now, PageRequest.of(0, limit));
    }

    @Transactional(readOnly = true)
    public List<SpacedRepetitionCard> getDifficultCards(User user, int limit) {
        // Cards with low success rate or high difficulty rating
        return cardRepository.findDifficultCardsForUser(user, PageRequest.of(0, limit));
    }

    @Transactional(readOnly = true)
    public ReviewStatistics getReviewStatistics(User user, LocalDate from, LocalDate to) {
        List<SpacedRepetitionCard> cards = cardRepository.findByUserAndLastReviewedBetween(
            user, from.atStartOfDay(), to.atTime(23, 59, 59));

        return ReviewStatistics.builder()
            .totalReviews(cards.stream().mapToInt(SpacedRepetitionCard::getTotalReviews).sum())
            .correctReviews(cards.stream().mapToInt(SpacedRepetitionCard::getCorrectReviews).sum())
            .averageAccuracy(calculateAverageAccuracy(cards))
            .streakDays(calculateStreakDays(user, to))
            .timeSpent(calculateTotalTimeSpent(cards))
            .cardsLearned(countCardsLearned(cards))
            .cardsMastered(countCardsMastered(cards))
            .build();
    }
}
```

### Review Session Management
```typescript
export interface ReviewSession {
  id: string;
  userId: string;
  mode: ReviewMode;
  startTime: Date;
  endTime?: Date;
  totalCards: number;
  completedCards: number;
  correctAnswers: number;
  averageResponseTime: number;
  isCompleted: boolean;
  cards: ReviewCard[];
  currentCardIndex: number;
}

export interface ReviewCard {
  id: string;
  wordId: string;
  word: string;
  definition: string;
  easeFactor: number;
  interval: number;
  repetitionCount: number;
  dueDate: Date;
  state: CardState;
  difficultyRating: number;
}

export enum ReviewMode {
  DUE_CARDS = 'due_cards',
  DIFFICULT_CARDS = 'difficult_cards',
  RANDOM_REVIEW = 'random_review',
  TARGETED_REVIEW = 'targeted_review'
}

export const useReviewSession = () => {
  const [session, setSession] = useState<ReviewSession | null>(null);
  const [currentCard, setCurrentCard] = useState<ReviewCard | null>(null);
  const [isLoading, setIsLoading] = useState(false);

  const startReview = async (mode: ReviewMode, limit: number = 20) => {
    setIsLoading(true);
    try {
      const response = await api.post('/api/reviews/start', { mode, limit });
      const newSession = response.data.data;
      setSession(newSession);
      setCurrentCard(newSession.cards[0]);
    } catch (error) {
      console.error('Failed to start review session:', error);
    } finally {
      setIsLoading(false);
    }
  };

  const submitReview = async (outcome: ReviewOutcome, responseTime: number) => {
    if (!session || !currentCard) return;

    try {
      const response = await api.post(`/api/reviews/${session.id}/submit`, {
        cardId: currentCard.id,
        outcome,
        responseTime
      });

      const updatedSession = response.data.data;
      setSession(updatedSession);

      // Move to next card
      const nextIndex = session.currentCardIndex + 1;
      if (nextIndex < session.cards.length) {
        setCurrentCard(session.cards[nextIndex]);
      } else {
        // Review session completed
        await completeReview();
      }
    } catch (error) {
      console.error('Failed to submit review:', error);
    }
  };

  const completeReview = async () => {
    if (!session) return;

    try {
      const response = await api.post(`/api/reviews/${session.id}/complete`);
      const completedSession = response.data.data;
      setSession(completedSession);
      return completedSession;
    } catch (error) {
      console.error('Failed to complete review:', error);
    }
  };

  return {
    session,
    currentCard,
    isLoading,
    startReview,
    submitReview,
    completeReview
  };
};
```

### Review Interface Components
```typescript
export const ReviewCard: React.FC<ReviewCardProps> = ({
  card,
  onSubmit,
  showAnswer,
  onToggleAnswer
}) => {
  const [responseTime, setResponseTime] = useState(0);
  const startTime = useRef<number>(Date.now());

  useEffect(() => {
    startTime.current = Date.now();
  }, [card]);

  const handleSubmit = (outcome: ReviewOutcome) => {
    const endTime = Date.now();
    const time = endTime - startTime.current;
    setResponseTime(time);
    onSubmit(outcome, time);
  };

  return (
    <Card className="w-full max-w-2xl mx-auto h-96">
      <CardHeader>
        <div className="flex justify-between items-center">
          <CardTitle>Review</CardTitle>
          <div className="flex gap-2">
            <Badge variant="outline">
              Interval: {card.interval} days
            </Badge>
            <Badge variant="secondary">
              Ease: {card.easeFactor.toFixed(2)}
            </Badge>
          </div>
        </div>
      </CardHeader>

      <CardContent className="h-full pb-20">
        <motion.div
          className="h-full flex flex-col justify-center items-center cursor-pointer"
          onClick={onToggleAnswer}
          whileHover={{ scale: 1.02 }}
        >
          <AnimatePresence mode="wait">
            {!showAnswer ? (
              <motion.div
                key="question"
                initial={{ opacity: 0 }}
                animate={{ opacity: 1 }}
                exit={{ opacity: 0 }}
                className="text-center"
              >
                <h2 className="text-4xl font-bold mb-6">{card.word}</h2>
                <p className="text-muted-foreground">Click to reveal definition</p>
              </motion.div>
            ) : (
              <motion.div
                key="answer"
                initial={{ opacity: 0 }}
                animate={{ opacity: 1 }}
                exit={{ opacity: 0 }}
                className="text-center"
              >
                <h3 className="text-2xl font-semibold mb-6">{card.definition}</h3>
                <div className="flex gap-3 justify-center">
                  <Button
                    variant="destructive"
                    onClick={(e) => {
                      e.stopPropagation();
                      handleSubmit(ReviewOutcome.AGAIN);
                    }}
                  >
                    Again
                  </Button>
                  <Button
                    variant="outline"
                    className="border-orange-300 text-orange-600 hover:bg-orange-50"
                    onClick={(e) => {
                      e.stopPropagation();
                      handleSubmit(ReviewOutcome.HARD);
                    }}
                  >
                    Hard
                  </Button>
                  <Button
                    variant="outline"
                    className="border-green-300 text-green-600 hover:bg-green-50"
                    onClick={(e) => {
                      e.stopPropagation();
                      handleSubmit(ReviewOutcome.GOOD);
                    }}
                  >
                    Good
                  </Button>
                  <Button
                    className="bg-blue-500 hover:bg-blue-600"
                    onClick={(e) => {
                      e.stopPropagation();
                      handleSubmit(ReviewOutcome.EASY);
                    }}
                  >
                    Easy
                  </Button>
                </div>
              </motion.div>
            )}
          </AnimatePresence>
        </motion.div>
      </CardContent>

      <div className="absolute bottom-0 left-0 right-0 p-4 bg-background border-t">
        <div className="flex justify-between items-center text-sm text-muted-foreground">
          <span>Response Time: {(responseTime / 1000).toFixed(1)}s</span>
          <span>Due: {formatDueDate(card.dueDate)}</span>
        </div>
      </div>
    </Card>
  );
};

export const ReviewDashboard: React.FC = () => {
  const { session, currentCard, startReview, submitReview } = useReviewSession();
  const [showAnswer, setShowAnswer] = useState(false);
  const [stats, setStats] = useState<ReviewStatistics | null>(null);

  useEffect(() => {
    loadReviewStatistics();
  }, []);

  const loadReviewStatistics = async () => {
    try {
      const response = await api.get('/api/reviews/statistics');
      setStats(response.data.data);
    } catch (error) {
      console.error('Failed to load statistics:', error);
    }
  };

  const handleStartReview = (mode: ReviewMode) => {
    startReview(mode, 20);
    setShowAnswer(false);
  };

  const handleSubmitReview = (outcome: ReviewOutcome, responseTime: number) => {
    submitReview(outcome, responseTime);
    setShowAnswer(false);
  };

  if (session && currentCard) {
    return (
      <div className="container mx-auto py-8">
        <ReviewProgress session={session} />
        <ReviewCard
          card={currentCard}
          onSubmit={handleSubmitReview}
          showAnswer={showAnswer}
          onToggleAnswer={() => setShowAnswer(!showAnswer)}
        />
      </div>
    );
  }

  return (
    <div className="container mx-auto py-8">
      <h1 className="text-3xl font-bold mb-8">Review Dashboard</h1>

      {stats && <ReviewStatisticsCard stats={stats} />}

      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6 mt-8">
        <ReviewModeCard
          title="Due Cards"
          description="Review cards that are due for practice"
          count={stats?.dueCardsCount || 0}
          onStart={() => handleStartReview(ReviewMode.DUE_CARDS)}
        />
        <ReviewModeCard
          title="Difficult Cards"
          description="Focus on challenging words"
          count={stats?.difficultCardsCount || 0}
          onStart={() => handleStartReview(ReviewMode.DIFFICULT_CARDS)}
        />
        <ReviewModeCard
          title="Random Review"
          description="Practice random words from your collection"
          count={stats?.totalCards || 0}
          onStart={() => handleStartReview(ReviewMode.RANDOM_REVIEW)}
        />
      </div>
    </div>
  );
};
```

### Review Analytics Service
```java
@Service
@Transactional(readOnly = true)
public class ReviewAnalyticsService {

    private final SpacedRepetitionCardRepository cardRepository;
    private final ReviewHistoryRepository reviewHistoryRepository;

    public ReviewInsights generateInsights(User user, LocalDate from, LocalDate to) {
        List<SpacedRepetitionCard> cards = cardRepository.findByUserAndLastReviewedBetween(
            user, from.atStartOfDay(), to.atTime(23, 59, 59));

        ReviewInsights insights = new ReviewInsights();
        insights.setLearningVelocity(calculateLearningVelocity(cards, from, to));
        insights.setRetentionRate(calculateRetentionRate(cards));
        insights.setOptimalReviewTime(findOptimalReviewTime(user));
        insights.setDifficultyDistribution(analyzeDifficultyDistribution(cards));
        insights.setLearningPredictions(generateLearningPredictions(user));
        insights.setRecommendations(generateRecommendations(user, cards));

        return insights;
    }

    private double calculateLearningVelocity(List<SpacedRepetitionCard> cards, LocalDate from, LocalDate to) {
        long daysBetween = ChronoUnit.DAYS.between(from, to);
        long newCardsLearned = cards.stream()
            .filter(card -> card.getState() == CardState.REVIEW)
            .count();

        return daysBetween > 0 ? (double) newCardsLearned / daysBetween : 0;
    }

    private double calculateRetentionRate(List<SpacedRepetitionCard> cards) {
        int totalReviews = cards.stream()
            .mapToInt(SpacedRepetitionCard::getTotalReviews)
            .sum();

        int correctReviews = cards.stream()
            .mapToInt(SpacedRepetitionCard::getCorrectReviews)
            .sum();

        return totalReviews > 0 ? (double) correctReviews / totalReviews * 100 : 0;
    }

    private LocalTime findOptimalReviewTime(User user) {
        // Analyze review performance by time of day
        List<ReviewSession> sessions = reviewHistoryRepository.findByUserOrderByStartTime(user);

        Map<Integer, Double> performanceByHour = sessions.stream()
            .collect(Collectors.groupingBy(
                session -> session.getStartTime().getHour(),
                Collectors.averagingDouble(ReviewSession::getAccuracy)
            ));

        return performanceByHour.entrySet().stream()
            .max(Map.Entry.comparingByValue())
            .map(entry -> LocalTime.of(entry.getKey(), 0))
            .orElse(LocalTime.of(9, 0)); // Default to 9 AM
    }

    private List<String> generateRecommendations(User user, List<SpacedRepetitionCard> cards) {
        List<String> recommendations = new ArrayList<>();

        double averageAccuracy = calculateRetentionRate(cards);
        if (averageAccuracy < 70) {
            recommendations.add("Consider reducing your daily new word limit to focus on retention");
        }

        long difficultCards = cards.stream()
            .filter(card -> card.getDifficultyRating().compareTo(new BigDecimal("0.7")) > 0)
            .count();

        if (difficultCards > cards.size() * 0.3) {
            recommendations.add("Focus on reviewing difficult cards more frequently");
        }

        // Add more recommendation logic...

        return recommendations;
    }
}
```

## Implementation Details

### Key Features
1. **Advanced Algorithms**: Implementation of SM-2 and FSRS algorithms for optimal spacing
2. **Adaptive Scheduling**: Dynamic interval adjustment based on individual performance
3. **Multiple Review Modes**: Targeted practice for different learning needs
4. **Performance Analytics**: Detailed insights into learning patterns and progress
5. **Smart Notifications**: Intelligent reminders based on optimal review timing
6. **Memory Model**: Scientific approach to memory retention and forgetting curves

### Performance Optimizations
- Efficient database queries with proper indexing
- Cached statistics for frequently accessed data
- Background processing for analytics calculations
- Optimized card scheduling algorithms

### User Experience
- Intuitive review interface with clear feedback
- Progress tracking and motivation features
- Customizable review parameters
- Achievement system for engagement

## Testing Strategy
- Unit tests for spaced repetition algorithms
- Integration tests for review session management
- Performance tests for large card collections
- A/B testing for algorithm effectiveness
- User experience testing for interface usability

## Definition of Done
- [ ] Spaced repetition algorithm implemented and tested
- [ ] Multiple review modes functional
- [ ] Performance analytics working correctly
- [ ] Notification system operational
- [ ] Review interface polished and responsive
- [ ] Database optimizations in place
- [ ] All tests passing with high coverage
- [ ] Algorithm effectiveness validated
- [ ] User documentation complete

## Notes
- Consider implementing multiple algorithm options for user preference
- Plan for algorithm parameter tuning based on user data
- Implement A/B testing framework for algorithm comparison
- Consider adding collaborative filtering for difficulty prediction