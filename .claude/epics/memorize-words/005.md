# Task 005: Learning Interface

## Metadata
```yaml
epic: memorize-words
task_number: 005
title: Learning Interface
status: completed
priority: high
effort_estimate: 14
parallel: false
dependencies: [004]
created: 2025-09-22T01:13:25Z
updated: 2025-09-22T01:13:25Z
assignee: developer
tags: [learning-interface, interactive-cards, shadcn-ui, react, typescript, word-learning]
```

## Summary
Create an engaging and intuitive learning interface using shadcn/ui card components for interactive word learning. The interface will provide multiple learning modes, progress tracking, and adaptive learning features to enhance vocabulary acquisition through spaced repetition and active recall techniques.

## Acceptance Criteria
- [ ] Interactive word cards with flip animations
- [ ] Multiple learning modes (flashcards, multiple choice, typing, pronunciation)
- [ ] Progress tracking during learning sessions
- [ ] Adaptive difficulty adjustment based on performance
- [ ] Session customization (duration, word count, difficulty level)
- [ ] Learning streaks and achievement system
- [ ] Audio pronunciation playback
- [ ] Visual feedback for correct/incorrect answers
- [ ] Session statistics and performance analytics
- [ ] Resume learning session functionality
- [ ] Keyboard shortcuts for efficient navigation
- [ ] Mobile-responsive design for all learning modes

## Technical Requirements

### Learning Session Types
```typescript
export enum LearningMode {
  FLASHCARDS = 'flashcards',
  MULTIPLE_CHOICE = 'multiple_choice',
  TYPING = 'typing',
  PRONUNCIATION = 'pronunciation',
  MIXED = 'mixed'
}

export enum DifficultyLevel {
  BEGINNER = 'beginner',
  INTERMEDIATE = 'intermediate',
  ADVANCED = 'advanced',
  MIXED = 'mixed'
}

export interface LearningSession {
  id: string;
  userId: string;
  vocabularyListId?: string;
  mode: LearningMode;
  difficulty: DifficultyLevel;
  totalWords: number;
  completedWords: number;
  correctAnswers: number;
  startTime: Date;
  endTime?: Date;
  duration?: number;
  isCompleted: boolean;
  isPaused: boolean;
  currentWordIndex: number;
  words: LearningWord[];
  settings: SessionSettings;
}

export interface LearningWord {
  id: string;
  word: string;
  definition: string;
  pronunciation?: string;
  example?: string;
  difficulty: DifficultyLevel;
  attempts: number;
  correctAttempts: number;
  isCompleted: boolean;
  timeSpent: number;
  lastAttemptAt?: Date;
}

export interface SessionSettings {
  autoAdvance: boolean;
  showDefinitionFirst: boolean;
  enablePronunciation: boolean;
  enableHints: boolean;
  timeLimit?: number;
  shuffleWords: boolean;
  repeatIncorrect: boolean;
}
```

### Word Card Component
```typescript
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Progress } from "@/components/ui/progress";
import { Badge } from "@/components/ui/badge";
import { Volume2, RotateCcw, CheckCircle, XCircle } from "lucide-react";
import { motion, AnimatePresence } from "framer-motion";

interface WordCardProps {
  word: LearningWord;
  mode: LearningMode;
  isFlipped: boolean;
  onFlip: () => void;
  onAnswer: (isCorrect: boolean, answer?: string) => void;
  onNext: () => void;
  onPrevious: () => void;
  enableAudio: boolean;
  showHints: boolean;
}

export const WordCard: React.FC<WordCardProps> = ({
  word,
  mode,
  isFlipped,
  onFlip,
  onAnswer,
  onNext,
  onPrevious,
  enableAudio,
  showHints
}) => {
  const [userAnswer, setUserAnswer] = useState('');
  const [showResult, setShowResult] = useState(false);
  const [isCorrect, setIsCorrect] = useState(false);

  const playPronunciation = async () => {
    if (word.pronunciation && enableAudio) {
      try {
        // Use Web Speech API or audio service
        const utterance = new SpeechSynthesisUtterance(word.word);
        speechSynthesis.speak(utterance);
      } catch (error) {
        console.error('Pronunciation playback failed:', error);
      }
    }
  };

  const handleSubmitAnswer = (answer: string) => {
    const correct = answer.toLowerCase().trim() === word.word.toLowerCase().trim();
    setIsCorrect(correct);
    setShowResult(true);
    onAnswer(correct, answer);
  };

  const renderLearningMode = () => {
    switch (mode) {
      case LearningMode.FLASHCARDS:
        return (
          <FlashcardMode
            word={word}
            isFlipped={isFlipped}
            onFlip={onFlip}
            onAnswer={onAnswer}
            playPronunciation={playPronunciation}
            enableAudio={enableAudio}
          />
        );

      case LearningMode.MULTIPLE_CHOICE:
        return (
          <MultipleChoiceMode
            word={word}
            onAnswer={handleSubmitAnswer}
            showResult={showResult}
            isCorrect={isCorrect}
          />
        );

      case LearningMode.TYPING:
        return (
          <TypingMode
            word={word}
            userAnswer={userAnswer}
            setUserAnswer={setUserAnswer}
            onSubmit={handleSubmitAnswer}
            showResult={showResult}
            isCorrect={isCorrect}
            showHints={showHints}
          />
        );

      default:
        return <FlashcardMode {...props} />;
    }
  };

  return (
    <motion.div
      initial={{ opacity: 0, y: 20 }}
      animate={{ opacity: 1, y: 0 }}
      exit={{ opacity: 0, y: -20 }}
      transition={{ duration: 0.3 }}
      className="w-full max-w-2xl mx-auto"
    >
      <Card className="h-96 relative overflow-hidden">
        <CardHeader className="pb-2">
          <div className="flex justify-between items-center">
            <CardTitle className="text-lg">
              Learning Mode: {mode.replace('_', ' ').toUpperCase()}
            </CardTitle>
            <div className="flex gap-2">
              <Badge variant={word.difficulty === 'advanced' ? 'destructive' : 'secondary'}>
                {word.difficulty}
              </Badge>
              {enableAudio && word.pronunciation && (
                <Button
                  variant="ghost"
                  size="sm"
                  onClick={playPronunciation}
                  className="p-2"
                >
                  <Volume2 className="h-4 w-4" />
                </Button>
              )}
            </div>
          </div>
        </CardHeader>

        <CardContent className="h-full pb-20">
          <AnimatePresence mode="wait">
            {renderLearningMode()}
          </AnimatePresence>
        </CardContent>

        <div className="absolute bottom-0 left-0 right-0 p-4 bg-background border-t">
          <div className="flex justify-between items-center">
            <Button variant="outline" onClick={onPrevious}>
              Previous
            </Button>

            <div className="flex gap-2">
              {showResult && (
                <motion.div
                  initial={{ scale: 0 }}
                  animate={{ scale: 1 }}
                  className="flex items-center gap-1"
                >
                  {isCorrect ? (
                    <CheckCircle className="h-5 w-5 text-green-500" />
                  ) : (
                    <XCircle className="h-5 w-5 text-red-500" />
                  )}
                </motion.div>
              )}
            </div>

            <Button onClick={onNext}>
              Next
            </Button>
          </div>
        </div>
      </Card>
    </motion.div>
  );
};
```

### Flashcard Mode Component
```typescript
const FlashcardMode: React.FC<FlashcardModeProps> = ({
  word,
  isFlipped,
  onFlip,
  onAnswer,
  playPronunciation,
  enableAudio
}) => {
  return (
    <motion.div
      className="h-full flex flex-col justify-center items-center cursor-pointer"
      onClick={onFlip}
      whileHover={{ scale: 1.02 }}
      whileTap={{ scale: 0.98 }}
    >
      <AnimatePresence mode="wait">
        {!isFlipped ? (
          <motion.div
            key="front"
            initial={{ rotateY: 0 }}
            animate={{ rotateY: 0 }}
            exit={{ rotateY: 90 }}
            transition={{ duration: 0.3 }}
            className="text-center"
          >
            <h2 className="text-4xl font-bold mb-4">{word.word}</h2>
            {word.pronunciation && (
              <p className="text-lg text-muted-foreground mb-6">
                /{word.pronunciation}/
              </p>
            )}
            <p className="text-sm text-muted-foreground">
              Click to reveal definition
            </p>
          </motion.div>
        ) : (
          <motion.div
            key="back"
            initial={{ rotateY: -90 }}
            animate={{ rotateY: 0 }}
            exit={{ rotateY: 90 }}
            transition={{ duration: 0.3 }}
            className="text-center"
          >
            <h3 className="text-2xl font-semibold mb-4">{word.definition}</h3>
            {word.example && (
              <blockquote className="text-lg italic text-muted-foreground mb-6">
                "{word.example}"
              </blockquote>
            )}
            <div className="flex gap-4 justify-center">
              <Button
                variant="outline"
                className="bg-red-50 hover:bg-red-100 border-red-200"
                onClick={(e) => {
                  e.stopPropagation();
                  onAnswer(false);
                }}
              >
                Don't Know
              </Button>
              <Button
                className="bg-green-50 hover:bg-green-100 border-green-200 text-green-700"
                onClick={(e) => {
                  e.stopPropagation();
                  onAnswer(true);
                }}
              >
                Know It
              </Button>
            </div>
          </motion.div>
        )}
      </AnimatePresence>
    </motion.div>
  );
};
```

### Multiple Choice Mode Component
```typescript
const MultipleChoiceMode: React.FC<MultipleChoiceModeProps> = ({
  word,
  onAnswer,
  showResult,
  isCorrect
}) => {
  const [selectedOption, setSelectedOption] = useState<string | null>(null);
  const [options, setOptions] = useState<string[]>([]);

  useEffect(() => {
    // Generate random options including the correct answer
    generateOptions();
  }, [word]);

  const generateOptions = () => {
    // This would call a service to get similar words or random words
    // For now, we'll use a placeholder
    const randomOptions = ['option1', 'option2', 'option3'];
    const allOptions = [word.word, ...randomOptions];
    setOptions(shuffleArray(allOptions));
  };

  const handleOptionSelect = (option: string) => {
    setSelectedOption(option);
    onAnswer(option);
  };

  return (
    <div className="h-full flex flex-col justify-center">
      <div className="text-center mb-8">
        <h2 className="text-2xl font-bold mb-4">What does this mean?</h2>
        <p className="text-xl bg-muted p-4 rounded-lg">{word.definition}</p>
      </div>

      <div className="grid grid-cols-2 gap-4">
        {options.map((option, index) => (
          <Button
            key={index}
            variant={selectedOption === option ? "default" : "outline"}
            className={cn(
              "h-16 text-lg",
              showResult && option === word.word && "bg-green-100 border-green-500",
              showResult && selectedOption === option && option !== word.word && "bg-red-100 border-red-500"
            )}
            onClick={() => handleOptionSelect(option)}
            disabled={showResult}
          >
            {option}
          </Button>
        ))}
      </div>

      {showResult && (
        <motion.div
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          className="mt-6 text-center"
        >
          <p className={cn(
            "text-lg font-semibold",
            isCorrect ? "text-green-600" : "text-red-600"
          )}>
            {isCorrect ? "Correct!" : `Incorrect. The answer is: ${word.word}`}
          </p>
        </motion.div>
      )}
    </div>
  );
};
```

### Learning Session Hook
```typescript
export const useLearningSession = (sessionConfig: LearningSessionConfig) => {
  const [session, setSession] = useState<LearningSession | null>(null);
  const [currentWord, setCurrentWord] = useState<LearningWord | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const startSession = async () => {
    try {
      setIsLoading(true);
      const response = await api.post('/api/learning-sessions', sessionConfig);
      const newSession = response.data.data;
      setSession(newSession);
      setCurrentWord(newSession.words[0]);
    } catch (err) {
      setError('Failed to start learning session');
    } finally {
      setIsLoading(false);
    }
  };

  const submitAnswer = async (isCorrect: boolean, answer?: string) => {
    if (!session || !currentWord) return;

    try {
      const response = await api.post(`/api/learning-sessions/${session.id}/answers`, {
        wordId: currentWord.id,
        isCorrect,
        answer,
        timeSpent: calculateTimeSpent()
      });

      const updatedSession = response.data.data;
      setSession(updatedSession);

      // Move to next word
      const nextIndex = session.currentWordIndex + 1;
      if (nextIndex < session.words.length) {
        setCurrentWord(session.words[nextIndex]);
      } else {
        // Session completed
        await completeSession();
      }
    } catch (err) {
      setError('Failed to submit answer');
    }
  };

  const pauseSession = async () => {
    if (!session) return;

    try {
      await api.patch(`/api/learning-sessions/${session.id}/pause`);
      setSession(prev => prev ? { ...prev, isPaused: true } : null);
    } catch (err) {
      setError('Failed to pause session');
    }
  };

  const resumeSession = async () => {
    if (!session) return;

    try {
      await api.patch(`/api/learning-sessions/${session.id}/resume`);
      setSession(prev => prev ? { ...prev, isPaused: false } : null);
    } catch (err) {
      setError('Failed to resume session');
    }
  };

  const completeSession = async () => {
    if (!session) return;

    try {
      const response = await api.patch(`/api/learning-sessions/${session.id}/complete`);
      const completedSession = response.data.data;
      setSession(completedSession);
      return completedSession;
    } catch (err) {
      setError('Failed to complete session');
    }
  };

  return {
    session,
    currentWord,
    isLoading,
    error,
    startSession,
    submitAnswer,
    pauseSession,
    resumeSession,
    completeSession
  };
};
```

### Learning Session Service (Backend)
```java
@Service
@Transactional
public class LearningSessionService {

    private final LearningSessionRepository sessionRepository;
    private final UserWordProgressService progressService;
    private final SpacedRepetitionService spacedRepetitionService;

    public LearningSessionDto startSession(CreateSessionRequest request, User user) {
        LearningSession session = new LearningSession();
        session.setUser(user);
        session.setMode(request.getMode());
        session.setDifficulty(request.getDifficulty());
        session.setVocabularyList(getVocabularyList(request.getVocabularyListId()));
        session.setSettings(request.getSettings());
        session.setStartTime(LocalDateTime.now());
        session.setStatus(SessionStatus.ACTIVE);

        // Select words based on spaced repetition algorithm
        List<Word> words = selectWordsForSession(request, user);
        session.setWords(words);
        session.setTotalWords(words.size());

        LearningSession savedSession = sessionRepository.save(session);
        return mapToDto(savedSession);
    }

    public LearningSessionDto submitAnswer(Long sessionId, SubmitAnswerRequest request, User user) {
        LearningSession session = getSessionWithValidation(sessionId, user);

        if (session.getStatus() != SessionStatus.ACTIVE) {
            throw new InvalidSessionStateException("Session is not active");
        }

        // Record the answer
        LearningAnswer answer = new LearningAnswer();
        answer.setSession(session);
        answer.setWord(getWordById(request.getWordId()));
        answer.setIsCorrect(request.getIsCorrect());
        answer.setUserAnswer(request.getAnswer());
        answer.setTimeSpent(request.getTimeSpent());
        answer.setAnsweredAt(LocalDateTime.now());

        session.getAnswers().add(answer);

        // Update progress
        progressService.updateProgress(user, request.getWordId(), request.getIsCorrect());

        // Update spaced repetition
        spacedRepetitionService.updateRepetition(user, request.getWordId(), request.getIsCorrect());

        // Move to next word
        session.setCurrentWordIndex(session.getCurrentWordIndex() + 1);

        if (request.getIsCorrect()) {
            session.setCorrectAnswers(session.getCorrectAnswers() + 1);
        }

        // Check if session is complete
        if (session.getCurrentWordIndex() >= session.getTotalWords()) {
            completeSession(session);
        }

        LearningSession updatedSession = sessionRepository.save(session);
        return mapToDto(updatedSession);
    }

    public LearningSessionDto pauseSession(Long sessionId, User user) {
        LearningSession session = getSessionWithValidation(sessionId, user);
        session.setStatus(SessionStatus.PAUSED);
        session.setPausedAt(LocalDateTime.now());

        LearningSession updatedSession = sessionRepository.save(session);
        return mapToDto(updatedSession);
    }

    public LearningSessionDto resumeSession(Long sessionId, User user) {
        LearningSession session = getSessionWithValidation(sessionId, user);
        session.setStatus(SessionStatus.ACTIVE);
        session.setResumedAt(LocalDateTime.now());

        LearningSession updatedSession = sessionRepository.save(session);
        return mapToDto(updatedSession);
    }

    private void completeSession(LearningSession session) {
        session.setStatus(SessionStatus.COMPLETED);
        session.setEndTime(LocalDateTime.now());
        session.setDuration(calculateDuration(session.getStartTime(), session.getEndTime()));

        // Calculate accuracy
        double accuracy = (double) session.getCorrectAnswers() / session.getTotalWords() * 100;
        session.setAccuracy(accuracy);

        // Award achievements if applicable
        achievementService.checkSessionAchievements(session);
    }

    private List<Word> selectWordsForSession(CreateSessionRequest request, User user) {
        if (request.getVocabularyListId() != null) {
            // Use specific vocabulary list
            VocabularyList list = vocabularyListRepository.findById(request.getVocabularyListId())
                .orElseThrow(() -> new ResourceNotFoundException("VocabularyList", "id", request.getVocabularyListId()));
            return new ArrayList<>(list.getWords());
        } else {
            // Use spaced repetition to select words due for review
            return spacedRepetitionService.getWordsForReview(user, request.getWordCount());
        }
    }
}
```

## Implementation Details

### Key Features
1. **Interactive Cards**: Smooth animations and transitions using framer-motion
2. **Multiple Modes**: Flashcards, multiple choice, typing, and pronunciation practice
3. **Adaptive Learning**: Difficulty adjustment based on user performance
4. **Progress Tracking**: Real-time session progress and statistics
5. **Audio Support**: Text-to-speech for pronunciation practice
6. **Keyboard Navigation**: Efficient controls for power users
7. **Mobile Responsive**: Touch-friendly interface for mobile devices

### User Experience
- Smooth card transitions and animations
- Immediate visual feedback for answers
- Progress indicators and session statistics
- Customizable session settings
- Achievement system for motivation

### Performance Optimizations
- Lazy loading of word data
- Efficient state management with React hooks
- Optimized animations for 60fps performance
- Preloading of audio pronunciation data

## Testing Strategy
- Unit tests for learning components
- Integration tests for session management
- User interaction tests with React Testing Library
- Performance tests for animations
- Accessibility tests for keyboard navigation
- Mobile responsiveness tests

## Definition of Done
- [ ] All learning modes implemented and functional
- [ ] Interactive card components working smoothly
- [ ] Progress tracking accurate and real-time
- [ ] Audio pronunciation working across browsers
- [ ] Session management (pause/resume) functional
- [ ] Mobile-responsive design completed
- [ ] Keyboard shortcuts implemented
- [ ] All tests passing with good coverage
- [ ] Performance requirements met
- [ ] Accessibility standards met

## Notes
- Consider implementing offline learning capabilities
- Plan for advanced features like voice recognition
- Implement analytics for learning pattern insights
- Consider gamification elements for engagement